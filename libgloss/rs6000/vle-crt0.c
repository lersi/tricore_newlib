/***************************************************************************/
/*

FILE
	crt0.c

	$Date: 2008/05/21 23:02:29 $
	$Revision: 1.15 $
DESCRIPTION

        GNU PPc VLE Runtime Initialization
	This file provides the first entry point, "_start" which is used by the linker as a
	program entry point.  It initializes the program state (registers,
	stack pointer, data pointers) and copies data images from ROM to RAM
	as necessary.
	
	
	void _start(void)
	
	Main entry point for the PPC EABI program.	It will call main().
	
	This file allows for board-level initialization.  Define a function
	called __init_hardware().

REFERENCES

	[EABI95]	PowerPC Embedded Application Binary Interface,
				32-bit Implementation.	Version 1.0, Initial Release,
				1/10/95.  Stephen Sobek, Motorola, and Kevin Burke, IBM.

NOTES

	The .PPC.EMB.sdata0 and .PPC.EMB.sbss section pointers are not
	currently supported
	
HISTORY
*/
/***************************************************************************/

//#include <mpc5516.h>
#include <string.h>

#define ASM_FUNC        __attribute__((naked))
#define SEC     __attribute__((section(".startup")))

/***************************************************************************/
/*
 *	external declarations
 */
/***************************************************************************/

/***************************************************************************/
/*
 *	function declarations
 */
/***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

extern void main();
void __init_data(void);
extern void exit(int);
__attribute__((section(".traptable"),naked)) void IVOR_table(void);
extern void __init_hardware(void);
extern void __init(void);

#ifdef __cplusplus
}
#endif

/***************************************************************************/
/*
 *	_start
 *
 *	PowerPC EABI Runtime Initialization.  Initialize pointers,
 *	initialize data, and call main().
 *
 *	This function is the very first location executed in a program, or
 *	the first location called by the board-level initialization.
 *	Memory access is not guaranteed to be safe until after __init_hardware.
 */
/***************************************************************************/

SEC ASM_FUNC void _start()
{
	/*
	 *  Set the MSR[LE] and MSR[ILE] bits if the target is little endian
	 */
	asm volatile("mfmsr %r3");
	asm volatile("oris  %r3, %r3, 0x0200");
	asm volatile("mtmsr %r3");

	/*
	 *	initialize stack pointer
	 */

	asm volatile ("lis      %r1, __USTACK@ha");	/* __USTACK is generated by linker */
	asm volatile ("addi     %r1, %r1, __USTACK@l");

	/*
	 *	initialize small data area pointers (EABI)
	 */
	asm volatile ("lis	%r2, _SDA2_BASE_@ha");	/* _SDA2_BASE_ is generated by linker */
	asm volatile ("addi	%r2, %r2, _SDA2_BASE_@l");

	asm volatile ("lis	%r13, _SDA_BASE_@ha");	/* _SDA_BASE_ is generated by linker */
	asm volatile ("addi	%r13, %r13, _SDA_BASE_@l");
		
	/*
	 *	board-level initialization
	 */
	__init_hardware();

	/*
	 *	Memory access is safe now.
	 */

	/*
	 *	Prepare a terminating stack record.
	 */
	asm volatile ("stwu	%r1, -8(%r1)");	/* embedded eabi required SP to always be 8-byte aligned */
	asm volatile ("li	%r0, 0x0000");	/* load up r0 with 0x00000000 */
	asm volatile ("stw	%r0,	0(%r1)");/* SysVr4 EABI Supp indicated that initial back 
                                                    chain word should be null */
	asm volatile ("li	%r0, -1");	/* load up r0 with 0xFFFFFFFF */
	asm volatile ("stw	%r0, 4(%r1)");	/* Make an illegal return address of 0xFFFFFFFF */

	 
        /*
         * set up the trap vector
         */
        asm volatile("mtivpr %0":: "r" (IVOR_table));
	/*
	 *	Data initialization: copy ROM data to RAM as necessary
	 */

	__init_data();
		
	/*
	 *	initialization before main
         *      execute constructors etc. from the init section
	 */
        __init();
	
	/*
	 *	branch to main program
	 */
	
	asm volatile ("li       %r3, 0");
	asm volatile ("li       %r4, 0");
	asm volatile ("li       %r5, 0");
	asm volatile ("bl       main");

	/*
	 *	exit program
	 */
	
	asm volatile ("b		exit");
        while(1);
}

/**************************************************************************/
/* branch tabel for the 16 MPC551x core interrupts/traps */
/**************************************************************************/
#define TRAP(n) \
 __asm__ volatile (".align 4"); \
 __asm__ volatile ("IVOR"#n"trap:       b  IVOR"#n"trap");

__attribute__((section(".traptable"),naked))
void IVOR_table(void)
{
  TRAP(0)
  TRAP(1)
  TRAP(2)
  TRAP(3)
  TRAP(4)
  TRAP(5)
  TRAP(6)
  TRAP(7)
  TRAP(8)
  TRAP(9)
  TRAP(10)
  TRAP(11)
  TRAP(12)
  TRAP(13)
  TRAP(14)
  TRAP(15)
}

/***************************************************************************/
/*
 *	__copy_rom_section
 *
 *	Copy the ROM section to RAM if dst and src are different and size
 *	is nonzero.
 *
 *	dst			destination RAM address
 *	src			source ROM address
 *	size		number of bytes to copy
 */
/***************************************************************************/
extern void __copy_rom_section(void* dst, const void* src, unsigned long size)
{
	if (size && (dst != src)) {
		memcpy(dst, src, size);
//		__flush_cache( dst, size );
	}
}


/***************************************************************************/
/*
 *	__init_bss_section
 *
 *	Initialize the RAM section to zeros if size is greater than zero.
 *
 *	dst			destination RAM address
 *	size		number of bytes to zero
 */
/***************************************************************************/
extern void __init_bss_section(void* dst, unsigned long size)
{
	if (size) {
		__builtin_memset(dst, 0, size);
	}
}


/***************************************************************************/
/*
 *	__init_data
 *
 *	Initialize all (RAM) data sections, copying ROM sections as necessary.
 *
 *	dst			destination RAM address
 *	size		number of bytes to zero
 *
 */
/***************************************************************************/
typedef struct {
        char *  rom_addr;       /* address in ROM */
        char *  ram_addr;       /* address in RAM */
        unsigned int size;      /* size of section */
} __rom_copy_info_t;

typedef struct {
        char *  ram_addr;       /* address in RAM */
        unsigned int size;      /* size of section */
} __bss_init_info_t;

extern __rom_copy_info_t        __rom_copy_info[];
extern __bss_init_info_t        __bss_init_info[];

void
__init_data(void)
{
  __rom_copy_info_t *prci;
  __bss_init_info_t *pbii;

  /* copy initialized section to RAM */
  for (prci = __rom_copy_info; prci->rom_addr != 0 || prci->ram_addr != 0
      || prci->size != 0; prci++)
    {
      __copy_rom_section(prci->ram_addr, prci->rom_addr, prci->size);
    }

  for (pbii = __bss_init_info; pbii->ram_addr != 0 || pbii->size != 0; pbii++)
    {
      __init_bss_section(pbii->ram_addr, pbii->size);
    }
}


/*
 * __init_hardware can be overriden by the application
 */
__attribute__ ((weak,naked)) void __init_hardware(void)
{
  __asm__ volatile ("blr");
}

int __exit_status = -1;

__attribute__ ((weak)) void _exit(int i)
{
  __exit_status = i;
#ifdef __PPC_VLE__
  asm volatile ("se_illegal");
#else
  asm volatile (".long 0");
#endif
  while(1);
}
void exit(int i)
{
  _exit(i);
}

void abort(void)
{
  _exit(-127);
}

__attribute__ ((weak)) int write (int d, char *bp, int len)
{
  return len;
}
